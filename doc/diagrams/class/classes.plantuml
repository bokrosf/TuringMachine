@startuml classes
hide interface empty members
hide enum empty members

class "Symbol<T>" as Symbol {
    -{static} NullValueHashCode: int = 0 {query}    
    {static} Symbol()
    +Symbol(value: T)
    +ToString(): string
    +Equals(obj: object?): bool
    +{static} Equality(left: Symbol<T>?, right: Symbol<T>): bool
    +{static} Inequality(left: Symbol<T>?, right: Symbol<T>): bool
    +GetHashCode(): int
    +{method} {static} Blank: Symbol<T> {query}
    +{method} Value: T {query}
}

class "State<T>" as State {
    -{static} NullValueHashCode: int = 0 {query}
    -{static} InitialHashCode: int = 1 {query}
    -{static} EndHashCode: int = 2 {query}
    -{static} FailureHashCode: int = 3 {query}
    {static} State()
    +State(value: T)
    +Equals(obj: object?): bool
    +{static} Equality(left: State<T>?, right: State<T>): bool
    +{static} Inequality(left: State<T>?, right: State<T>): bool
    +GetHashCode(): int
    +{method} {static} Initial: T {query}
    +{method} {static} End: T {query}
    +{method} {static} Failure: T {query}
    +{method} Value: T {query}
}

Symbol -[hidden]- State

enum TapeHeadDirection {
    Stay
    Left
    Right
}

class "Tape<T>" as Tape {
    -symbols: LinkedList<Symbol<T>>
    -head: LinkedListNode<Symbol<T>>
    +Tape()
    +Tape(symbols: IEnumerable<Symbol<T>>)
    +MoveHeadInDirection(direction: TapeHeadDirection): Symbol<T>
    +Clear(): void
    +{method} CurrentSymbol: Symbol<T> {query}
    -MoveHeadToTheLeft(): Symbol<T>
    -MoveHeadToTheRight(): Symbol<T>
}

Tape "*" o-left- "1..*" Symbol
interface "IEnumerable<T>" as IEnumerable
IEnumerable <|.. Tape
Tape --> TapeHeadDirection


class "TransitionDomain<TState, TValue>" as TransitionDomain << record >> {
    +{method} State: State<TState> {query}
    +{method} Symbol: Symbol<TValue> {query}
    +Implicit(state: TState, value: TValue): TransitionDomain<TState, TValue>
    +Implicit(state: State<TState>, symbol: Symbol<TValue>): TransitionDomain<TState, TValue>
}

class "TransitionRange<TState, TValue>" as TransitionRange << record >> {
    +{method} HeadDirection: TapeHeadDirection {query}
    +Implicit(state: TState, value: TValue, headDirection: TapeHeadDirection): TransitionRange<TState, TValue>
    +Implicit(state: State<TState>, symbol: Symbol<TValue>, headDirection: TapeHeadDirection): TransitionRange<TState, TValue>
}

class "Transition<TState, TValue>" as Transition << record >> {
    +{method} Domain: TransitionDomain<TState, TValue> {query}
    +{method} Range: TransitionRange<TState, TValue> {query}
    +Implicit(domain: TransitionDomain<TState, TValue>, range: TransitionRange<TState, TValue>): Transition<TState, TValue>
}


class "TransitionTable<TState, TValue>" as TransitionTable {
    -transitions: ReadOnlyDictionary<TState, TValue>
    +TransitionTable(transitions: IEnumerable<Transition<TState, TValue>>)
    ~[](TransitionDomain<TState, TValue> domain): TransitionRange
}

class "TransitionCollectionValidator<TState, TValue>" as TransitionCollectionValidator {
    +Validate(transitions: IEnumerable<Transition<TState, TValue>>): void
    -CheckDuplications(transitions: IEnumerable<Transition<TState, TValue>>): void
    -CheckDeterminism(transitions: IEnumerable<Transition<TState, TValue>>): void
    -CheckStates(transitions: IEnumerable<Transition<TState, TValue>>): void
    -CheckStateOfDomain(transition: Transition<TState, TValue>): void
    -CheckStateOfRange(transition: Transition<TState, TValue>): void
}

TransitionDomain <|-- TransitionRange
Transition "*" o-- "1" TransitionDomain
Transition "*" o-- "1" TransitionRange
TransitionTable "*" o-- "1..*" TransitionDomain
TransitionTable "*" o-- "1..*" TransitionRange
TransitionTable --> "Validate()" TransitionCollectionValidator

Tape -[hidden]right- Transition

@enduml