@startuml classes

hide interface empty members
hide enum empty members

class "Symbol<T>" as Symbol {
    -{static} NullValueHashCode: int = 0 {query}    
    {static} Symbol()
    +Symbol(value: T)
    +ToString(): string
    +Equals(obj: object?): bool
    +{static} Equality(left: Symbol<T>?, right: Symbol<T>): bool
    +{static} Inequality(left: Symbol<T>?, right: Symbol<T>): bool
    +GetHashCode(): int
    +{method} {static} Blank: Symbol<T> {query}
    +{method} Value: T {query}
}

enum TapeHeadDirection {
    Stay
    Left
    Right
}

class "Tape<T>" as Tape {
    -symbols: LinkedList<Symbol<T>>
    -head: LinkedListNode<Symbol<T>>
    +Tape()
    +Tape(symbols: IEnumerable<Symbol<T>>)
    +MoveHeadInDirection(direction: TapeHeadDirection): Symbol<T>
    +Clear(): void
    +{method} CurrentSymbol: Symbol<T> {query}
    -MoveHeadToTheLeft(): Symbol<T>
    -MoveHeadToTheRight(): Symbol<T>
}

Tape "*" o-left- "1..*" Symbol
interface "IEnumerable<T>" as IEnumerable
IEnumerable <|.. Tape
Tape --> TapeHeadDirection


class "TransitionDomain<TState, TValue>" as TransitionDomain << record >> {
    +{method} State: TState {query}
    +{method} Symbol: Symbol<TValue> {query}
    +Implicit(state: TState, value: TValue): TransitionDomain<TState, TValue>
    +Implicit(state: TState, symbol: Symbol<TValue>): TransitionDomain<TState, TValue>
}

class "TransitionRange<TState, TValue>" as TransitionRange << record >> {
    +{method} HeadDirection: TapeHeadDirection {query}
    +Implicit(state: TState, value: TValue, headDirection: TapeHeadDirection): TransitionRange<TState, TValue>
    +Implicit(state: TState, symbol: Symbol<TValue>, headDirection: TapeHeadDirection): TransitionRange<TState, TValue>
}

class "Transition<TState, TValue>" as Transition << record >> {
    +{method} Domain: TransitionDomain<TState, TValue> {query}
    +{method} Range: TransitionRange<TState, TValue> {query}
    +Implicit(domain: TransitionDomain<TState, TValue>, range: TransitionRange<TState, TValue>): Transition<TState, TValue>
}

interface "IReadOnlySingleTapeTransitionTable<TState, TValue>" as IReadOnlySingleTapeTransitionTable {
    GetRange(domain: TransitionDomain<TState, TValue>): TransitionRange<TState, TValue>
}

interface "IReadOnlyMultiTapeTransitionTable<TState, TValue>" as IReadOnlyMultiTapeTransitionTable {
    GetRangeAtTape(tapeId: int, domain: TransitionDomain<TState, TValue>): TransitionRange<TState, TValue>
}

~abstract class "ReadOnlyTransitionTable<TState, TValue>" as ReadOnlyTransitionTable {
    #transitionTable: TransitionTable<TState, TValue>
}

class "ReadOnlySingleTapeTransitionTable<TState, TValue>" as ReadOnlySingleTapeTransitionTable
class "ReadOnlyMultiTapeTransitionTable<TState, TValue>" as ReadOnlyMultiTapeTransitionTable

abstract class "TransitionTableBuilder<TState, TValue>" as TransitionTableBuilder {
    #transitionTable: TransitionTable<TState, TValue>
}

class "SingleTapeTransitionTableBuilder<TState, TValue>" as SingleTapeTransitionTableBuilder {
    AddTransition(transition: Transition<TState, TValue>): SingleTapeTransitionTableBuilder<TState, TValue>
    AddTransition(domain: TransitionDomain<TState, TValue>, range: TransitionRange<TState, TValue>): SingleTapeTransitionTableBuilder<TState, TValue>
    Build(): IReadOnlySingleTapeTransitionTable<TState, TValue>
}

class "MultiTapeTransitionTableBuilder<TState, TValue>" as MultiTapeTransitionTableBuilder {
    AddTransition(tapeId: int, transition: Transition<TState, TValue>): MultiTapeTransitionTableBuilder<TState, TValue>
    AddTransition(tapeId: int, domain: TransitionDomain<TState, TValue>, range: TransitionRange<TState, TValue>): MultiTapeTransitionTableBuilder<TState, TValue>
    Build(): IReadOnlyMultiTapeTransitionTable<TState, TValue>
}

+class "TransitionTable<TState, TValue>" as TransitionTable {
    -transitionsPerTapes: Dictionary<int, TapeTransitionTable<TState, TValue>>
    ~TransitionTable(tapeCount: int)
    ~AddTransition(transition: Transition<TState, TValue>): void
    ~AddTransition(domain: TransitionDomain<TState, TValue>, range: TransitionRange<TState, TValue>): void
    ~AddTransition(tapeId: int, transition: Transition<TState, TValue>): void
    ~AddTransition(tapeId: int, domain: TransitionDomain<TState, TValue>, range: TransitionRange<TState, TValue>): void
    +{method} {static} InitialState: TState {query}
    +{method} {static} EndState: TState {query}
    +{method} {static} FailureState: TState {query}
}

~class "TapeTransitionTable<TState, TValue>" as TapeTransitionTable {
    -transitions: Dictionary<TransitionDomain<TState, TValue>, TransitionRange<TState, TValue>
    +{method} Item[TransitionDomain<TState, TValue>]: TransitionRange<TState, TValue>
}

IReadOnlySingleTapeTransitionTable <|.down. TransitionTable
IReadOnlyMultiTapeTransitionTable <|.down. TransitionTable
TransitionTable -[hidden]up- ReadOnlySingleTapeTransitionTable
TransitionTable -[hidden]up- ReadOnlyMultiTapeTransitionTable
ReadOnlyTransitionTable <|-down- ReadOnlySingleTapeTransitionTable
ReadOnlyTransitionTable <|-down- ReadOnlyMultiTapeTransitionTable
IReadOnlySingleTapeTransitionTable <|.down. ReadOnlySingleTapeTransitionTable
IReadOnlyMultiTapeTransitionTable <|.down. ReadOnlyMultiTapeTransitionTable
TransitionTableBuilder <|-- SingleTapeTransitionTableBuilder
TransitionTableBuilder <|-- MultiTapeTransitionTableBuilder
TransitionDomain <|-- TransitionRange
Transition "*" o-- "1" TransitionDomain
Transition "*" o-- "1" TransitionRange
TransitionTable "1" *-- "1..*" TapeTransitionTable
TapeTransitionTable "*" o-- "1..*" TransitionDomain
TapeTransitionTable "*" o-- "1..*" TransitionRange

TransitionTable -[hidden]right- SingleTapeTransitionTableBuilder
Tape -[hidden]right- Transition

@enduml