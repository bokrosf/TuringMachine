@startuml classes
hide interface empty members
hide enum empty members

class "Symbol<T>" as Symbol {
    -{static} NullValueHashCode: int = 0 {query}    
    {static} Symbol()
    +Symbol(value: T)
    +ToString(): string
    +Equals(obj: object?): bool
    +{static} Equality(left: Symbol<T>?, right: Symbol<T>): bool
    +{static} Inequality(left: Symbol<T>?, right: Symbol<T>): bool
    +GetHashCode(): int
    +{method} {static} Blank: Symbol<T> {query}
    +{method} Value: T {query}
}

class "State<T>" as State {
    -{static} NullValueHashCode: int = 0 {query}
    -{static} InitialHashCode: int = 100003 {query}
    -{static} AcceptHashCode: int = 500009 {query}
    -{static} FailureHashCode: int = 900007 {query}
    {static} State()
    +State(value: T)
    +ToString(): string
    +Equals(obj: object?): bool
    +{static} Equality(left: State<T>?, right: State<T>): bool
    +{static} Inequality(left: State<T>?, right: State<T>): bool
    +GetHashCode(): int
    +{method} {static} Initial: T {query}
    +{method} {static} Accept: T {query}
    +{method} {static} Failure: T {query}
    +{method} Value: T {query}
}

Symbol -[hidden]- State

enum TapeHeadDirection {
    Stay
    Left
    Right
}

class "Tape<T>" as Tape {
    -symbols: LinkedList<Symbol<T>>
    -head: LinkedListNode<Symbol<T>>
    +Tape()
    +Tape(symbols: IEnumerable<Symbol<T>>)
    +MoveHeadInDirection(direction: TapeHeadDirection): Symbol<T>
    +Clear(): void
    +{method} CurrentSymbol: Symbol<T> {query}
    -MoveHeadToTheLeft(): Symbol<T>
    -MoveHeadToTheRight(): Symbol<T>
}

Tape "*" o-left- "1..*" Symbol
interface "IEnumerable<T>" as IEnumerable
IEnumerable <|.. Tape
Tape ..> TapeHeadDirection


class "TransitionDomain<TState, TSymbol>" as TransitionDomain << record >> {
    +{method} State: State<TState> {query}
    +{method} Symbol: Symbol<TSymbol> {query}
    +Implicit(state: TState, value: TSymbol): TransitionDomain<TState, TSymbol>
    +Implicit(state: State<TState>, symbol: Symbol<TSymbol>): TransitionDomain<TState, TSymbol>
}

class "TransitionRange<TState, TSymbol>" as TransitionRange << record >> {
    +{method} HeadDirection: TapeHeadDirection {query}
    +Implicit(state: TState, value: TSymbol, headDirection: TapeHeadDirection): TransitionRange<TState, TSymbol>
    +Implicit(state: State<TState>, symbol: Symbol<TSymbol>, headDirection: TapeHeadDirection): TransitionRange<TState, TSymbol>
}

class "Transition<TState, TSymbol>" as Transition << record >> {
    +{method} Domain: TransitionDomain<TState, TSymbol> {query}
    +{method} Range: TransitionRange<TState, TSymbol> {query}
    +Implicit(domain: TransitionDomain<TState, TSymbol>, range: TransitionRange<TState, TSymbol>): Transition<TState, TSymbol>
}


class "TransitionTable<TState, TSymbol>" as TransitionTable {
    -transitions: ReadOnlyDictionary<TState, TSymbol>
    +TransitionTable(transitions: IEnumerable<Transition<TState, TSymbol>>)
    ~[](TransitionDomain<TState, TSymbol> domain): TransitionRange
}

class "TransitionCollectionValidator<TState, TSymbol>" as TransitionCollectionValidator {
    +Validate(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckDuplications(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckDeterminism(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckStates(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckStateOfDomain(transition: Transition<TState, TSymbol>): void
    -CheckStateOfRange(transition: Transition<TState, TSymbol>): void
}

interface "IAutomaticComputation<TSymbol>" as IAutomaticComputation {
    StartComputationAsync(input: IEnumerable<Symbol<TSymbol>>): Task
    StartComputation(input: IEnumerable<Symbol<TSymbol>>, maxStepCount: int): void
    StartComputation(input: IEnumerable<Symbol<TSymbol>>, TimeSpan: timeout): void
    StartComputationAsync(input: IEnumerable<Symbol<TSymbol>>, cancellationToken: CancellationToken): Task
    StartComputationAsync(input: IEnumerable<Symbol<TSymbol>>, maxStepCount: int): Task
    StartComputationAsync(input: IEnumerable<Symbol<TSymbol>>, TimeSpan: timeout): Task
}

interface "IManualComputation<TSymbol>" as IManualComputation {
    StartComputation(input: IEnumerable<Symbol<TSymbol>>): void
    StartComputation(input: IEnumerable<Symbol<TSymbol>>, maxStepCount: int): void
    Step(): bool
    Abort(): void
}

interface "IComputationTracking<TState, TSymbol>" as IComputationTracking {
    Stepped: EventHandler<SteppedEventArgs<TState, TSymbol>>
    ComputationEnded: EventHandler<ComputationEndedEventArgs<TState>>
}

abstract class ComputationStateChangedEventArgs {
    +{method} StepCount: int {query}
    +{method} Duration: TimeSpan {query}
}

class "SteppedEventArgs<TState, TSymbol>" as SteppedEventArgs {
    +{method} Transition: Transition<TState, TSymbol> {query}
}

class "ComputationTerminatedEventArgs<TState, TSymbol>" as ComputationTerminatedEventArgs {
    +{method} State: TState {query}
    +{method} Result: IReadOnlyList<Symbol<TSymbol>> {query}
}

enum ComputationMode {
    Automatic,
    Manual
}

class "SingleTapeMachine<TState, TSymbol>" as SingleTapeMachine {
    -computationLock: object
    -computationMode: ComputationMode?
    -stepCount: int
    -tape: Tape<TSymbol>
    -configuration: TransitionDomain<TState, TSymbol>?
    -transitionTable: TransitionTable<TState, TSymbol>
    +SingleTapeMachine(transitionTable: TransitionTable<TState, TSymbol>)
    -ResetToComputation(input: IEnumerable<Symbol<TSymbol>>): void
    -ComputeAsync(cancellationToken: CancellationToken?, maxStepCount: int?): Task
    -TransitToNextConfiguration(): void
    -CanTerminate(): void
    -Terminate(): void
    -OnStepped(): void
    -OnComputationTerminated(): void
}

TransitionDomain <|-- TransitionRange
Transition "*" o-- "1" TransitionDomain
Transition "*" o-- "1" TransitionRange
TransitionTable "*" o-- "1..*" TransitionDomain
TransitionTable "*" o-- "1..*" TransitionRange
TransitionTable --> "Validate()" TransitionCollectionValidator

Tape -[hidden]right- Transition

ComputationStateChangedEventArgs <|-- SteppedEventArgs
ComputationStateChangedEventArgs <|-- ComputationTerminatedEventArgs

IAutomaticComputation <|.. SingleTapeMachine
IManualComputation <|.. SingleTapeMachine
IComputationTracking <|.. SingleTapeMachine
SingleTapeMachine *-- Tape
SingleTapeMachine "*" o-- "1" TransitionTable
SingleTapeMachine "1..*" *-- "0..1" ComputationMode   

@enduml