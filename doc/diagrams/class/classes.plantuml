@startuml classes
hide interface empty members
hide enum empty members

class "Symbol<T>" as Symbol {
    -{static} NullValueHashCode: int = 0 {query}    
    {static} Symbol()
    +Symbol(value: T)
    +ToString(): string
    +Equals(obj: object?): bool
    +{static} Equality(left: Symbol<T>?, right: Symbol<T>): bool
    +{static} Inequality(left: Symbol<T>?, right: Symbol<T>): bool
    +GetHashCode(): int
    +{method} {static} Blank: Symbol<T> {query}
    +{method} Value: T {query}
}

class "State<T>" as State {
    -{static} NullValueHashCode: int = 0 {query}
    -{static} InitialHashCode: int = 100003 {query}
    -{static} AcceptHashCode: int = 500009 {query}
    -{static} RejectHashCode: int = 900007 {query}
    {static} State()
    +State(value: T)
    +ToString(): string
    +Equals(obj: object?): bool
    +{static} Equality(left: State<T>?, right: State<T>): bool
    +{static} Inequality(left: State<T>?, right: State<T>): bool
    +GetHashCode(): int
    +{method} {static} Initial: T {query}
    +{method} {static} Accept: T {query}
    +{method} {static} Reject: T {query}
    +{method} Value: T {query}
}

Symbol -[hidden]- State

enum TapeHeadDirection {
    Stay
    Left
    Right
}

class "Tape<T>" as Tape {
    -symbols: LinkedList<Symbol<T>>
    -head: LinkedListNode<Symbol<T>>
    +Tape()
    +Tape(symbols: IEnumerable<Symbol<T>>)
    +MoveHeadInDirection(direction: TapeHeadDirection): Symbol<T>
    +Clear(): void
    +{method} CurrentSymbol: Symbol<T> {query}
    -MoveHeadToTheLeft(): Symbol<T>
    -MoveHeadToTheRight(): Symbol<T>
}

Tape "*" o-left- "1..*" Symbol
interface "IEnumerable<T>" as IEnumerable
IEnumerable <|.. Tape
Tape ..> TapeHeadDirection


class "TransitionDomain<TState, TSymbol>" as TransitionDomain << record >> {
    +{method} State: State<TState> {query}
    +{method} Symbol: Symbol<TSymbol> {query}
    +Implicit(state: TState, value: TSymbol): TransitionDomain<TState, TSymbol>
    +Implicit(state: State<TState>, symbol: Symbol<TSymbol>): TransitionDomain<TState, TSymbol>
}

class "TransitionRange<TState, TSymbol>" as TransitionRange << record >> {
    +{method} HeadDirection: TapeHeadDirection {query}
    +Implicit(state: TState, value: TSymbol, headDirection: TapeHeadDirection): TransitionRange<TState, TSymbol>
    +Implicit(state: State<TState>, symbol: Symbol<TSymbol>, headDirection: TapeHeadDirection): TransitionRange<TState, TSymbol>
}

class "Transition<TState, TSymbol>" as Transition << record >> {
    +{method} Domain: TransitionDomain<TState, TSymbol> {query}
    +{method} Range: TransitionRange<TState, TSymbol> {query}
    +Implicit(domain: TransitionDomain<TState, TSymbol>, range: TransitionRange<TState, TSymbol>): Transition<TState, TSymbol>
}


class "TransitionTable<TState, TSymbol>" as TransitionTable {
    -transitions: ReadOnlyDictionary<TState, TSymbol>
    +TransitionTable(transitions: IEnumerable<Transition<TState, TSymbol>>)
    ~[](TransitionDomain<TState, TSymbol> domain): TransitionRange
}

class "TransitionCollectionValidator<TState, TSymbol>" as TransitionCollectionValidator {
    +Validate(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckDuplications(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckDeterminism(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckStates(transitions: IEnumerable<Transition<TState, TSymbol>>): void
    -CheckStateOfDomain(transition: Transition<TState, TSymbol>): void
    -CheckStateOfRange(transition: Transition<TState, TSymbol>): void
}

interface "IAutomaticComputation<TState, TSymbol>" as IAutomaticComputation {
    StartComputationAsync(input: IEnumerable<Symbol<TSymbol>>): Task
    StartComputationAsync(input: IEnumerable<Symbol<TSymbol>>, constraint: ComputationConstraint<TState, TSymbol>): Task
    StartComputation(input: IEnumerable<Symbol<TSymbol>>): void
    StartComputation(input: IEnumerable<Symbol<TSymbol>>, constraint: ComputationConstraint<TState, TSymbol>): void
}

interface "IManualComputation<TState, TSymbol>" as IManualComputation {
    StartComputation(input: IEnumerable<Symbol<TSymbol>>): void
    StartComputation(input: IEnumerable<Symbol<TSymbol>>, constraint: ComputationConstraint<TState, TSymbol>): void
    Step(): bool
    Abort(): void
}

interface "IComputationTracking<TState, TSymbol>" as IComputationTracking {
    Stepped: EventHandler<SteppedEventArgs<TState, TSymbol>>?
    ComputationTerminated: EventHandler<ComputationTerminatedEventArgs<TState>>?
    ComputationAborted: EventHandler<ComputationAbortedEventArgs<TState, TSymbol>>?
}

abstract class ComputationStateChangedEventArgs {
    +{method} StepCount: int {query}
    +{method} Duration: TimeSpan {query}
}

class "SteppedEventArgs<TState, TSymbol>" as SteppedEventArgs {
    +{method} Transition: Transition<TState, TSymbol> {query}
}

class "ComputationTerminatedEventArgs<TState, TSymbol>" as ComputationTerminatedEventArgs {
    +{method} State: TState {query}
    +{method} Result: IReadOnlyList<Symbol<TSymbol>> {query}
}

class "ComputationAbortedEventArgs<TState, TSymbol>" as ComputationAbortedEventArgs {
    +{method} Exception: Exception {query}
}

enum ComputationMode {
    Automatic,
    Manual
}

class "SingleTapeMachine<TState, TSymbol>" as SingleTapeMachine {
    -computationLock: object
    -computationMode: ComputationMode?
    -computationState: ComputationState<TSymbol, TState>?    
    -tape: Tape<TSymbol>
    -transitionTable: TransitionTable<TState, TSymbol>
    +SingleTapeMachine(transitionTable: TransitionTable<TState, TSymbol>)
    -InitializeComputation(computationMode: ComputationMode, input: IEnumerable<Symbol<TSymbol>>): void
    -ComputeAsync(constraint: ComputationConstraint<TState, TSymbol>?): Task
    -TransitToNextConfiguration(): void
    -CanTerminate(): bool
    -Terminate(): void
    -CleanupComputation(): void
    -OnStepped(): void
    -OnComputationTerminated(): void
}

interface "IReadOnlyComputationState<TState, TSymbol>" as IReadOnlyComputationState {
    {method} Configuration: TransitionDomain<TState, TSymbol> {query}
    {method} StepCount: int {query}
    {method} Duration: TimeSpan {query}
}

interface "IComputationState<TState, TSymbol>" as IComputationState {
    {method} Configuration: TransitionDomain<TState, TSymbol>
    {method} StepCount: int
    {method} Duration: TimeSpan
    UpdateConfiguration(configuration: TransitionDomain<TState, TSymbol>): void
    StartDurationWatch(): void
    StopDurationWatch(): void
}

class "ComputationState<TState, TSymbol>" as ComputationState {
    -durationWatch: StopWatch
    +ComputationState(symbol: Symbol<TSymbol>)
    +AsReadOnly(): IReadOnlyComputationState<TState, TSymbol>
}

class "ReadOnlyComputationState<TState, TSymbol>" as ReadOnlyComputationState {
    -computationState: IComputationState<TState, TSymbol>
    +ReadOnlyComputationState(computationState: IComputationState<TState, TSymbol>)
}

IComputationState <|.. ComputationState
IReadOnlyComputationState <|.. ReadOnlyComputationState
IReadOnlyComputationState <|.. ComputationState
ReadOnlyComputationState -[hidden]up- ComputationState

abstract class "ComputationConstraint<TState, TSymbol>" as ComputationConstraint {
    +{abstract} Enforce(IReadOnlyComputationState<TState, TSymbol> computationState): void
    #IsComputationFinished(computationState: IReadOnlyComputationState<TState, TSymbol>): bool    
    -GetFinishedStates(): IEnumerable<State<TState>
}

class "CancellationConstraint<TState, TSymbol>" as CancellationConstraint {
    -cancellationToken: CancellationToken
    +CancellationConstraint(cancellationToken: CancellationToken)
}

class "StepLimitConstraint<TState, TSymbol>" as StepLimitConstraint {
    -stepLimit: int
    +StepLimitConstraint(stepLimit: int)
}

class "TimeLimitConstraint<TState, TSymbol>" as TimeLimitConstraint {
    -timeLimit: TimeSpan
    +TimeLimitConstraint(timeout: TimeSpan)
}

TransitionDomain <|-- TransitionRange
Transition "*" o-- "1" TransitionDomain
Transition "*" o-- "1" TransitionRange
TransitionTable "*" o-- "1..*" TransitionDomain
TransitionTable "*" o-- "1..*" TransitionRange
TransitionTable --> "Validate()" TransitionCollectionValidator

Tape -[hidden]right- Transition

ComputationStateChangedEventArgs <|-- SteppedEventArgs
ComputationStateChangedEventArgs <|-- ComputationTerminatedEventArgs
ComputationTerminatedEventArgs <|-- ComputationAbortedEventArgs

IAutomaticComputation <|.. SingleTapeMachine
IManualComputation <|.. SingleTapeMachine
IComputationTracking <|.. SingleTapeMachine
SingleTapeMachine *-- Tape
SingleTapeMachine "*" o-- "1" TransitionTable
SingleTapeMachine "1..*" *-- "0..1" ComputationMode   

ComputationConstraint <|-- CancellationConstraint
ComputationConstraint <|-- StepLimitConstraint
ComputationConstraint <|-- TimeLimitConstraint

@enduml